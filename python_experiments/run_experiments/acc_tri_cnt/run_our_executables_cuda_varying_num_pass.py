import socket
from exec_utilities import time_out_util
from config import *
from exec_utilities.exec_utils import *


def run_exp(env_tag=knl_tag):
    with open('config.json') as ifs:
        my_config_dict = json.load(ifs)[env_tag]
    ######################
    our_exec_path = my_config_dict["our_exec_cuda_path"]
    data_set_path = my_config_dict[data_set_path_tag]
    ######################

    our_exec_name_lst = [
        'scan-xp-cuda-experimental-hybrid-kernels-varying-multi-pass',
        'scan-xp-cuda-experimental-bitmap1D-varying-multi-pass',
        'scan-xp-cuda-experimental-bitmap-varying-multi-pass'
    ]
    data_set_lst = [
        'snap_friendster', 'webgraph_twitter',
        # "webgraph_webbase", "webgraph_it"
    ]

    exp_res_root_name = 'exp_results'
    folder_name = 'overview-10-17-varying-num-pass'

    # parameters
    eps_lst = [0.2]
    mu_lst = [5]
    thread_num = my_config_dict[thread_num_tag]
    thread_num_lst = [thread_num]

    # num_pass_lst = range(3, 16) + range(1, 3)

    def one_round(is_rev_deg=False, num_of_gpus=1):
        for data_set_name in data_set_lst:
            if is_rev_deg:
                data_set_name = data_set_name + os.sep + rev_deg_order_tag
            for our_algorithm in our_exec_name_lst:
                if 'friendster' in data_set_name and 'bitmap' in our_algorithm:
                    num_pass_lst = list(reversed(range(3, 11)))
                else:
                    num_pass_lst = list(reversed(range(1, 11)))
                for eps in eps_lst:
                    for mu in mu_lst:
                        for t_num in thread_num_lst:
                            for num_pass in num_pass_lst:
                                statistics_dir = os.sep.join(
                                    map(str,
                                        ['.', exp_res_root_name, folder_name + '-' + str(num_of_gpus),
                                         num_pass,
                                         data_set_name, eps, mu, t_num]))
                                os.system('mkdir -p ' + statistics_dir)
                                statistics_file_path = statistics_dir + os.sep + our_algorithm + '.txt'
                                # 1st: write header
                                os.system(
                                    ' '.join(
                                        ['echo', my_splitter + time.ctime() + my_splitter, '>>', statistics_file_path]))

                                # 2nd: run exec cmd
                                algorithm_path = our_exec_path + os.sep + our_algorithm
                                params_lst = map(str,
                                                 [algorithm_path,
                                                  data_set_path + os.sep + data_set_name,
                                                  eps, mu, t_num, num_pass, statistics_file_path, '> /dev/null 2>&1'])
                                cmd = ' '.join(params_lst)
                                time_out = 3600

                                my_env = os.environ.copy()
                                my_env["CUDA_VISIBLE_DEVICES"] = ','.join(map(str, range(4, 4 + num_of_gpus)))
                                tle_flag, info, correct_info = time_out_util.run_with_timeout(cmd, timeout_sec=time_out,
                                                                                              env=my_env)

                                # check md5 for correctness, assuming result generated by ppSCAN
                                def check_result():
                                    tmp_lst = []
                                    gt_res_file_name = '-'.join(map(str, ['result', eps, mu])) + '.txt'
                                    res_file_path = os.sep.join(
                                        [data_set_path, data_set_name, 'scanxp-' + gt_res_file_name])
                                    tmp_tle_flag, tmp_info, tmp_correct_info = time_out_util.run_with_timeout(
                                        ' '.join(['md5sum', res_file_path]),
                                        timeout_sec=time_out)
                                    tmp_lst.append(tmp_info + tmp_correct_info)

                                    tmp_tle_flag, tmp_info, tmp_correct_info = time_out_util.run_with_timeout(
                                        ' '.join(['md5sum', os.sep.join(
                                            [data_set_path, data_set_name, gt_res_file_name])]), timeout_sec=time_out)
                                    tmp_lst.append(tmp_info + tmp_correct_info)
                                    if len(tmp_lst[0].split()) > 0 and len(tmp_lst[1].split()) > 0 and \
                                            tmp_lst[0].split()[0] == tmp_lst[1].split()[0]:
                                        return True
                                    else:
                                        return 'False\n' + '\n'.join(map(str, tmp_lst))

                                # 3rd: append outputs
                                write_split(statistics_file_path)
                                with open(statistics_file_path, 'a+') as ifs:
                                    ifs.write(correct_info)
                                    ifs.write('\nis_time_out:' + str(tle_flag))
                                    ifs.write('\nis_correct:' + str(check_result()) + '\n')
                                    ifs.write(my_splitter + time.ctime() + my_splitter)
                                    ifs.write('\n\n\n\n')

    one_round(is_rev_deg=True, num_of_gpus=1)


if __name__ == '__main__':
    hostname = socket.gethostname()
    if hostname.startswith('lccpu12'):
        run_exp(env_tag=lccpu12_tag)
    else:
        print('not supported')
